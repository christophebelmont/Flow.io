# Auto-generate Core/Generated/ModuleDataModel_Generated.h
# Scans for ModuleDataModel.h files under src/Modules and aggregates them into RuntimeData.

import os
import re
from pathlib import Path

Import = type("Import", (), {})

# PlatformIO provides the project directory via env
try:
    Import("env")  # type: ignore
except Exception:
    env = None


def _get_project_dir():
    if env is not None:
        try:
            return env.get("PROJECT_DIR")
        except Exception:
            pass
    # Fallback for manual runs
    return os.getcwd()


def _find_module_models(modules_root: Path):
    return sorted(modules_root.rglob("*ModuleDataModel.h"))

def _find_module_runtimes(modules_root: Path):
    return sorted(modules_root.rglob("*Runtime.h"))

def _parse_entry(path: Path):
    # Expect a line like: // MODULE_DATA_MODEL: TypeName memberName
    pattern = re.compile(r"^\s*//\s*MODULE_DATA_MODEL:\s*([A-Za-z_][A-Za-z0-9_]*)\s+([A-Za-z_][A-Za-z0-9_]*)\s*$")
    with path.open("r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            match = pattern.match(line)
            if match:
                return match.group(1), match.group(2)
    return None


def _has_runtime_public_marker(path: Path):
    pattern = re.compile(r"^\s*//\s*RUNTIME_PUBLIC\b")
    with path.open("r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            if pattern.match(line):
                return True
    return False


def _write_generated(out_path: Path, rel_includes, entries):
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with out_path.open("w", encoding="utf-8") as f:
        f.write("#pragma once\n")
        f.write("/**\n")
        f.write(" * @file ModuleDataModel_Generated.h\n")
        f.write(" * @brief Auto-generated RuntimeData aggregation.\n")
        f.write(" */\n\n")
        f.write("// This file is generated by scripts/generate_datamodel.py\n")
        f.write("// Do not edit manually.\n\n")
        f.write("#ifndef RUNTIME_DATA_CORE_FIELDS\n")
        f.write("#define RUNTIME_DATA_CORE_FIELDS\n")
        f.write("#endif\n\n")

        for inc in rel_includes:
            f.write(f'#include "{inc}"\n')

        f.write("\nstruct RuntimeData {\n")
        f.write("    RUNTIME_DATA_CORE_FIELDS\n")
        for type_name, member_name in entries:
            f.write(f"    {type_name} {member_name};\n")
        f.write("};\n")

def _write_runtime_generated(out_path: Path, rel_includes):
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with out_path.open("w", encoding="utf-8") as f:
        f.write("#pragma once\n")
        f.write("/**\n")
        f.write(" * @file ModuleRuntime_Generated.h\n")
        f.write(" * @brief Auto-generated runtime helpers aggregation.\n")
        f.write(" */\n\n")
        f.write("// This file is generated by scripts/generate_datamodel.py\n")
        f.write("// Do not edit manually.\n\n")
        for inc in rel_includes:
            f.write(f'#include "{inc}"\n')


def main():
    project_dir = Path(_get_project_dir())
    src_root = project_dir / "src"
    modules_root = src_root / "Modules"
    out_path = src_root / "Core" / "Generated" / "ModuleDataModel_Generated.h"
    out_runtime_path = src_root / "Core" / "Generated" / "ModuleRuntime_Generated.h"

    if not modules_root.exists():
        _write_generated(out_path, [], [])
        _write_runtime_generated(out_runtime_path, [])
        return

    model_files = _find_module_models(modules_root)
    runtime_files = _find_module_runtimes(modules_root)

    entries = []
    rel_includes = []
    seen_members = set()

    for path in model_files:
        entry = _parse_entry(path)
        if not entry:
            # Skip files without a declaration marker
            continue
        type_name, member_name = entry
        if member_name in seen_members:
            raise RuntimeError(f"Duplicate RuntimeData member '{member_name}' in {path}")
        seen_members.add(member_name)

        rel = path.relative_to(src_root).as_posix()
        rel_includes.append(rel)
        entries.append((type_name, member_name))

    _write_generated(out_path, rel_includes, entries)

    runtime_includes = []
    for path in runtime_files:
        if not _has_runtime_public_marker(path):
            continue
        rel = path.relative_to(src_root).as_posix()
        runtime_includes.append(rel)

    _write_runtime_generated(out_runtime_path, runtime_includes)


main()
